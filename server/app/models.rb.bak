require 'sequel'
require 'bcrypt'

db_file = Pathname.new(__dir__).join('../database/blogapp.sqlite').to_s

DB = Sequel.sqlite db_file

Sequel::Model.plugin	:timestamps,
						:create    => :created_at,
						:update    => :updated_at,
						:force    => true,
						:update_on_create => true

class User < Sequel::Model(DB[:users])

    one_to_many         :posts,
                        :key   => :user_id,
                        :class => :Post

    def self.login data
        user = self.find(email: data[:email])
        raise "Invalid User" if !user

        password_digest = BCrypt::Password.new(user.password_digest)
        raise "Invalid Password" if password_digest != data[:password]
        username = user.username
        createdDate = user.created_at

        user.update(
            token: SecureRandom.hex(10),
        )

        {
            token: user.token,
            email: data[:email],
            username: username,
            created_at: createdDate
        }
        
    end

    def self.register data
        raise "Username is required" if data[:username].nil?
        raise "Email is required" if data[:email].nil?

        exist_user = self.find(username: data[:username])
        
        user_obj = {
            username: data[:username],
            email: data[:email],
            password_digest: BCrypt::Password.create(data[:password])
        }

        if exist_user
            exist_user.update(user_obj)
        else
            new_user = User.new(user_obj)
            new_user.save
        end
        
        user_obj
    end

end

class Post < Sequel::Model(DB[:posts])
    
    one_to_many         :comments,
    :key   => :post_id,
    :class => :Comment
    
    def self.create_post data
        raise "Title is Required" if data[:title].nil?
        raise "Provide some content" if data[:content].nil?
        # raise "image is required" if data[:pic].nil?
        raise "Category is required" if data[:category].nil?
        raise "Visibilty is required" if data[:visibility].nil?

        token = data[:an_token] || data[:an_token] || nil
        puts token
        raise "No token." if token.nil?

        user = User.find(token: token)
        raise "only registered users are allowed" if !user
    
        filename = nil
        if data[:pic] and data[:pic][:tempfile]
            fileptr = data[:pic][:tempfile]
    
            fileext = data[:pic][:type].split('/')[1]
            filename = "#{Util.getUniqueName}.#{fileext}"
    
            file_save_as = "#{$uploads_dir}/#{filename}"
    
            File.open(file_save_as, "wb") do |save_file|
                save_file.write(fileptr.read)
            end
        end
    
        post = {
            title: data[:title],
            content: data[:content],
            visibility: data[:visibility],
            category: data[:category],
            user_id: user.id
            # image_url: filename
        }
        
        post = Post.new(post)
        post.save
        
        post.values.merge(
            image_url: "#{$server_url}#{$uploads_path}#{post.values[:image_url]}"
        )
        post
    end
    
    def delete_post
        raise "post is already deleted" if self.deleted?
        self.soft_delete
    end

    def update_post data
        raise "Title is Required" if data[:title].nil?
        raise "Provide some content" if data[:content].nil?
        # raise "image is required" if data[:pic].nil?
        raise "Category is required" if data[:category].nil?
        raise "Visibilty is required" if data[:visibility].nil?


        filename = nil
        if data[:pic] and data[:pic][:tempfile]
            fileptr = data[:pic][:tempfile]

            fileext = data[:pic][:type].split('/')[1]
            filename = "#{Util.getUniqueName}.#{fileext}"

            file_save_as = "#{$uploads_dir}/#{filename}"

            File.open(file_save_as, "wb") do |save_file|
                save_file.write(fileptr.read)
            end
        end

        update_post = {
            title: data[:title],
            content: data[:content],
            visibility: data[:visibility],
            category: data[:category],
            image_url: filename
        }

        self.update(update_post);
        update_post
    end

    def self.get_all_posts
        all_posts = Post.reverse(:created_at).all.collect do |post|
            {
                id: post.id,
                title: post.title,
                content: post.content,
                created_date: post.created_at,
                visibility: post.visibility,
                category: post.category,
                image_url: "#{$server_url}#{$uploads_path}#{post.values[:image_url]}"
            }
        end
        all_posts
    end

    def get_user_post
        user_post = Post.reverse(:created_at).where(user_id: self.id).all.collect do |post|
            {
                id: post.id,
                title: post.title,
                content: post.content,
                created_date: post.created_at,
                visibility: post.visibility,
                category: post.category,
                image_url: "#{$server_url}#{$uploads_path}#{post.values[:image_url]}"
            }
        end
        user_post
    end

    def get_post
        post = Post.reverse(:created_at).where(id: self.id).all.collect do |post|
            {
                id: post.id,
                title: post.title,
                content: post.content,
                created_date: post.created_at,
                visibility: post.visibility,
                category: post.category,
                image_url: "#{$server_url}#{$uploads_path}#{post.values[:image_url]}"
            }
        end
        post
    end

    def create_comment data
        comment = {
            name: data[:name],
            comment: data[:comment],
            post_id: data[:post_id]
        }
        comment = self.add_comment(comment);
        comment.save
        comment
    end

    def get_all_comments
        comments = Comment.reverse(:created_at).where(post_id: self.id).all.collect do |comment|
            {
                name: comment.name,
                comment: comment.comment
            }
        end
        comments
    end
end

class Comment < Sequel::Model(DB[:comments])
    
end